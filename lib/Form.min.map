{"version":3,"sources":["webpack://formla/webpack/universalModuleDefinition","webpack://formla/webpack/bootstrap","webpack://formla/./src/utils.js","webpack://formla/./src/Errors.js","webpack://formla/./src/Form.js","webpack://formla/./src/http.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","m","hasOwnProperty","Object","prototype","isFile","val","Blob","isObj","value","isArr","Array","isNil","isStr","Errors","this","errors","elements","field","RegExp","keys","some","key","test","length","error","get","force","has","timeout","setTimeout","clear","el","forEach","addElement","push","options","behavior","inline","element","find","rx","expression","string","replace","escapeRegExp","scrollIntoView","flattenToQueryParams","data","prefix","params","item","paramKey","formValueToString","toString","Form","setOptions","originalData","originalConstantData","append","defaultOptions","constant","parseData","defineProperty","set","Error","newValue","setData","autoRemoveError","obj","call","hasOwn","original","emptyValue","clone","JSON","parse","stringify","event","node","target","HTMLInputElement","name","DragEvent","dataTransfer","files","url","submit","method","parseOptions","formData","requestOptions","getData","shouldConvertToFormData","FormData","httpAdapter","sendWith","buildBaseUrl","then","response","isValidationError","onFail","onSuccess","catch","Promise","reject","bubbleError","useJson","hasFile","strictMode","containsFile","i","File","reset","quiet","formatErrorResponse","record","hasElements","scrollToFirst","includes","baseUrl","relativeUrl","queryStart","fullUrl","properties","join","xhr","XMLHttpRequest","resolve","onload","status","onerror","open","setRequestHeader","send","e","values","message","isValidErrorObject","c","d","getter","o","enumerable","r","Symbol","toStringTag","t","mode","__esModule","ns","create","bind","n","object","property","p","s","moduleId","l","modules"],"mappings":"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","file":"Form.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"formla\"] = factory();\n\telse\n\t\troot[\"formla\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// @flow\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport function hasOwn (obj: Object, key: string): boolean %checks {\n    return hasOwnProperty.call(obj, key)\n}\n\nexport function isFile(val: mixed): boolean %checks {\n    return !!val && (val instanceof Blob);\n}\n\nexport function clone(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\nexport function emptyValue(original: mixed): Array<any> | {} | '' | null {\n    if (original instanceof Array) {\n        return [];\n    }\n    if (typeof original === 'object') {\n        return {};\n    }\n    if (typeof original === 'string') {\n        return '';\n    }\n    return null;\n}\n\nexport function isObj(value: mixed): boolean %checks {\n    return value !== null && typeof value === 'object';\n}\n\nexport function isArr(value: mixed): %checks {\n    return value instanceof Array;\n}\n\nexport function isNil(value: mixed): %checks {\n    return value == null;\n}\n\nexport function isFunc(value: mixed): %checks {\n    return value instanceof Function;\n}\n\nexport function isStr(value: mixed): %checks {\n    return typeof value === 'string';\n}\n\nexport function escapeRegExp(string: string) {\n    return string.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n}\n\nexport function containsFile(obj: any): boolean {\n    if (isArr(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            if (obj[i] instanceof File) {\n                return true;\n            }\n            if (isObj(obj[i])) {\n                return containsFile(obj[i]);\n            }\n        }\n    } else {\n        for (let key in obj) {\n            if (obj[key] instanceof File) {\n                return true;\n            }\n            if (isObj(obj[key])) {\n                return containsFile(obj[key]);\n            }\n        }\n    }\n    return false;\n}\n","// @flow\nimport {escapeRegExp, isArr, isNil} from \"./utils\";\n\ntype ErrorValue = string | Array<string>;\nexport type ErrorValues = { [string]: ErrorValue };\n\nclass Errors {\n\n    errors: ErrorValues;\n    elements: Array<{ key: string | RegExp, el: Element }>;\n\n    /**\n     * Create a new Errors instance.\n     */\n    constructor() {\n        this.errors = {};\n        this.elements = [];\n    }\n\n    /**\n     * Determine if an errors exists for the given field.\n     *\n     * @param {string|RegExp} field\n     */\n    has(field: string | RegExp): boolean {\n        if (field instanceof RegExp) {\n            return Object.keys(this.errors).some(key => field.test(key));\n        }\n        return this.errors.hasOwnProperty(field);\n    }\n\n    /**\n     * Determine if we have any errors.\n     */\n    any(): boolean {\n        return Object.keys(this.errors).length > 0;\n    }\n\n    /**\n     * Retrieve the error message for a field.\n     *\n     * @param {string} field\n     */\n    getFirst(field: string): ?string {\n        let error = this.get(field);\n        if (error) {\n            if (isArr(error)) {\n                return error.length ? error[0] : null;\n            } else {\n                return error || null;\n            }\n        }\n    }\n\n    get(field: string) {\n        return this.errors[field];\n    }\n\n    /**\n     * Add a new error message if one doesn't already exist.\n     *\n     * @param {string} field\n     * @param error\n     * @param force\n     */\n    add(field: string, error: ErrorValue, force: boolean = false) {\n        if (!this.has(field) || force) {\n            this.errors[field] = error;\n        }\n    }\n\n    /**\n     * Record the new errors.\n     *\n     * @param {object} errors\n     * @param timeout\n     */\n    record(errors: ErrorValues, timeout: ?(false | number) = 3000) {\n        this.errors = errors;\n        if (timeout) {\n            window.setTimeout(() => {\n                this.clear();\n            }, timeout);\n        }\n    }\n\n    /**\n     * Clear one or all error fields.\n     *\n     * @param {string|null} field\n     */\n    clear(field: ?string) {\n        if (field) {\n            delete this.errors[field];\n\n            return;\n        }\n\n        this.errors = {};\n    }\n\n    addElement(key: string | RegExp | string[], el: Element) {\n        if (isArr(key)) {\n            key.forEach(field => this.addElement(field, el));\n        } else {\n            this.elements.push({ key, el });\n        }\n    }\n\n    hasElements(): boolean {\n        return !!this.elements.length;\n    }\n\n    scrollToFirst(options: ?boolean | {\n        behavior?: ('auto' | 'instant' | 'smooth'),\n        block?: ('start' | 'center' | 'end' | 'nearest'),\n        inline?: ('start' | 'center' | 'end' | 'nearest'),\n    } = null) {\n        options = isNil(options) ? { behavior: 'smooth', inline: 'center' } : options;\n\n        const element = this.elements.find(({ key, el }) => {\n            let rx: RegExp;\n            if (key instanceof RegExp) {\n                rx = key;\n            } else {\n                let expression = escapeRegExp(key);\n                rx = new RegExp(expression.replace('*', '.*'));\n            }\n\n            if (Object.keys(this.errors).some(key => rx.test(key))) {\n                return true;\n            }\n        });\n\n        if (element) {\n            element.el.scrollIntoView(options);\n        }\n    }\n}\n\nexport default Errors;\n","// @flow\nimport {isFile, clone, hasOwn, emptyValue, isObj, isNil, isArr, containsFile, isStr} from \"./utils\";\nimport Errors from \"./Errors\";\nimport http from \"./http\";\nimport type { Method } from './flow';\nimport type { ErrorValues } from \"./Errors\";\n\ntype ErrorResponse = {\n    status: number,\n    response: {\n        errors: {\n            [string]: Array<string> | string\n        }\n    }\n}\n\ntype PrimitiveFormValue = string | number | boolean | null | typeof undefined;\n\ntype ScalarFormValue = PrimitiveFormValue | Blob | File;\n\ntype FormValue = ScalarFormValue | Array<?FormValue> | { [string]: ?FormValue };\n\nexport type Data = { [string]: FormValue };\n\ntype Options = {\n    method: Method,\n    baseUrl: string,\n    url: string,\n    sendWith: (method: Method, url: string, data: FormData | Data) => Promise<any>,\n    useJson: boolean,\n    strictMode: boolean,\n    isValidationError: ({ status: number }) => boolean,\n    formatErrorResponse: (any) => ErrorValues,\n    timeout: false | number,\n    autoRemoveError: boolean,\n    clear: boolean,\n    quiet: boolean,\n    clone: boolean,\n}\n\ntype PartialOptions = $Shape<Options>;\n\nfunction parseOptions(method: ?(Method | PartialOptions), url: ?(string | PartialOptions), options: ?PartialOptions): PartialOptions {\n    method = method ? (isObj(method) ? method : { method }) : {};\n    url = url ? (isObj(url) ? url : { url }) : {};\n    options = options || {};\n\n    return {\n        ...options,\n        ...url,\n        ...method,\n    }\n}\n\nfunction flattenToQueryParams(data: Data | Array<FormValue>, prefix: string = ''): { [string]: string | Blob | File } {\n    let params = {};\n\n    if (isArr(data)) {\n        data.forEach(item => {\n            let paramKey = `${prefix}[]`;\n\n            if (isObj(item) && !isFile(item)) {\n                params = {\n                    ...params,\n                    ...flattenToQueryParams(item, paramKey)\n                };\n                return;\n            }\n\n            params[paramKey] = isFile(item) ? item : formValueToString(item);\n        })\n    } else {\n        Object.keys(data).forEach(key => {\n            let item = data[key];\n\n            let paramKey = prefix ? `${prefix}[${key}]` : '' + key;\n\n            if (isObj(item) && !isFile(item)) {\n                params = {\n                    ...params,\n                    ...flattenToQueryParams(item, paramKey)\n                };\n                return;\n            }\n\n            params[paramKey] = isFile(item) ? item : formValueToString(item);\n        });\n    }\n\n    return params;\n}\n\nfunction formValueToString(value: PrimitiveFormValue): string {\n    if (typeof value === 'boolean') {\n        return ''+(+value);\n    }\n    if (typeof value === 'number') {\n        return value.toString();\n    }\n    return value || '';\n}\n\nfunction bubbleError(error: Error | Object): Promise<Object> {\n    if (error instanceof Error) {\n        throw error;\n    }\n    return Promise.reject(error);\n}\n\nfunction isValidErrorObject(errors) {\n    return !errors ||\n        typeof errors !== 'object' ||\n        !Object.keys(errors).length ||\n        Object.values(errors).some(error => {\n            if (isArr(error)) {\n                return error.some(message => !isStr(message));\n            }\n            return !isStr(error);\n        });\n}\n\nclass Form {\n\n    errors: Errors;\n\n    data: Data;\n    originalData: Data;\n    originalConstantData: Data;\n    options: Options;\n\n    static defaultOptions: Options = {\n        // The default method type used by the submit method\n        method: 'post',\n\n        // If set any relative urls will be appended to the baseUrl\n        baseUrl: '',\n\n        // The url to submit the form\n        url: '',\n\n        // A callback to implement custom HTTP logic.\n        // It is recommended to use this option so the form can utilise your HTTP library.\n        // The callback should return a promise that the form can use to handle the response.\n        sendWith: http,\n\n        // Set to true if you want the form to submit the data as a json object.\n        // This will pass the data as a JavaScript object to the sendWith callback so it is up to you to stringify it for your HTTP library.\n        // If the data contains a File or Blob object the data will be a FormData object regardless of this option (unless strictMode is true).\n        useJson: false,\n\n        // If set to true the form will throw an Error if the data has a File or Blob object and the useJson option is true.\n        strictMode: false,\n\n        // The status code for which the form should handle validation errors.\n        isValidationError: ({ status }) => status === 422,\n\n        // A callback that should turn the error response into an object of field names and their validation errors.\n        formatErrorResponse: (response) => {\n            let data = response.data || response.response;\n            if (typeof data === 'string') {\n                try {\n                    data = JSON.parse(data);\n                } catch (e) {\n                    throw new Error('Unable to find errors in the response');\n                }\n            }\n            let errors: ErrorValues = data.errors;\n            if (isValidErrorObject(errors)) {\n                throw new Error('Unable to find errors in the response');\n            }\n            return errors;\n        },\n\n        // The number of milliseconds to wait before clearing the error messages.\n        // When timeout is false the error messages will stay indefinitely.\n        timeout: false,\n\n        // When set to true the errors for a field will be cleared when that field's value is updated.\n        autoRemoveError: true,\n\n        // When set to true, the data will be reverted to it's original values after a successful request.\n        clear: true,\n\n        // When set to true, no errors will be recorded.\n        quiet: false,\n\n        // If clone is set to false any nested objects and arrays will be stored in the form by reference.\n        clone: true,\n    };\n\n    static setOptions = function (options: Options) {\n        Form.defaultOptions = {\n            ...Form.defaultOptions,\n            ...options\n        };\n    };\n\n    constructor(data: Data, options: ?Options) {\n        this.setOptions(options);\n\n        this.originalData = {};\n        this.originalConstantData = {};\n        this.data = {};\n\n        this.append(data);\n\n        this.errors = new Errors();\n    }\n\n    setOptions(options: ?Options) {\n        this.options = this.options || Form.defaultOptions;\n        if (options) {\n            this.options = {\n                ...this.options,\n                ...options,\n            }\n        }\n    }\n\n    append(key: string | Data, value: FormValue, constant: ?boolean = false): Form {\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(field => {\n                this.append(field, key[field], constant);\n            });\n            return this;\n        }\n\n        value = this.parseData(value);\n        if (constant) {\n            this.originalConstantData[key] = value;\n        } else {\n            this.originalData[key] = value;\n        }\n        if (!constant) {\n            this.data[key] = value;\n            this.defineProperty(key);\n        } else {\n            Object.defineProperty(\n                this,\n                key,\n                {\n                    get: () => undefined,\n                    set: () => {\n                        throw new Error(`The \"${key}\" value has been set as constant and cannot be modified`);\n                    }\n                }\n            );\n        }\n\n        return this;\n    }\n\n    defineProperty(key: string) {\n        Object.defineProperty(\n            this,\n            key,\n            {\n                get: () => this.data[key],\n                set: (newValue: FormValue) => {\n                    this.setData(key, newValue);\n                }\n            }\n        );\n    }\n\n    constantData(key: string | Data, value: FormValue): Form {\n        return this.append(key, value, true);\n    }\n\n    getData(): Data {\n        return {\n            ...this.data,\n            ...this.originalConstantData,\n        }\n    }\n\n    setData(key: string, value: FormValue) {\n        this.data[key] = value;\n        if (this.options.autoRemoveError) {\n            this.errors.clear(key);\n        }\n    }\n\n    reset(): Form {\n        for (let field in this.data) {\n            this.data[field] = this.originalData[field];\n        }\n\n        this.errors.clear();\n\n        return this;\n    }\n\n    clear(field: string): Form {\n        if (hasOwn(this, field)) {\n            this.data[field] = emptyValue(this.data[field]);\n        }\n        return this;\n    }\n\n    parseData(data: FormValue): FormValue {\n        return this.options.clone && !isFile(data) ? clone(data) : data;\n    }\n\n    addFileFromEvent(event: Event | DragEvent, key: ?string): Form {\n        let node = event.target;\n        if (!(node instanceof HTMLInputElement)) {\n            throw new Error('Incompatible event target, must be of type HTMLInputElement');\n        }\n        if (!key) {\n            key = node.name;\n        }\n        if (key in this && (node.value !== '')) {\n            if (event instanceof DragEvent) {\n                this.setData(key, event.dataTransfer && event.dataTransfer.files.length && event.dataTransfer.files[0]);\n            } else {\n                this.setData(key, node.files && node.files.length && node.files[0]);\n            }\n            node.value = '';\n        }\n        return this;\n    }\n\n    post(url: string | Options, options: ?Options): Promise<any> {\n        return this.submit('post', url, options);\n    }\n\n    put(url: string | Options, options: ?Options): Promise<any> {\n        return this.submit('put', url, options);\n    }\n\n    patch(url: string | Options, options: ?Options): Promise<any> {\n        return this.submit('patch', url, options);\n    }\n\n    delete(url: string | Options, options: ?Options): Promise<any> {\n        return this.submit('delete', url, options);\n    }\n\n    get(url: string | Options, options: ?Options): Promise<any> {\n        return this.submit('get', url, options);\n    }\n\n    submit(method: Method | Options, url: ?string | Options, options: ?Options): Promise<any> {\n        options = parseOptions(method, url, options);\n        const requestOptions = {\n            ...this.options,\n            ...options,\n        };\n\n        let formData, data = this.getData();\n        if (this.shouldConvertToFormData(requestOptions)) {\n            formData = new FormData();\n\n            let params = flattenToQueryParams(data);\n\n            Object.keys(params).forEach(key => {\n                formData.append(key, params[key]);\n            });\n\n            data = formData;\n        }\n\n        let httpAdapter = requestOptions.sendWith;\n\n        return httpAdapter(requestOptions.method, this.buildBaseUrl(requestOptions), data).then(response => {\n            if (requestOptions.isValidationError(response)) {\n                this.onFail(response, requestOptions);\n            } else {\n                this.onSuccess(requestOptions);\n            }\n            return response;\n        }).catch(error => {\n            if (requestOptions.isValidationError(error)) {\n                this.onFail(error, requestOptions);\n            }\n            return bubbleError(error);\n        });\n    }\n\n    shouldConvertToFormData(options: ?Options) {\n        options = options || this.options;\n        if (!options.useJson) {\n            return true;\n        }\n        if (this.hasFile() && options.strictMode) {\n            throw new Error('Cannot convert a file to JSON');\n        }\n        return this.hasFile();\n    }\n\n    hasFile(): boolean {\n        return containsFile(this.getData());\n    }\n\n    onSuccess(options: ?Options) {\n        options = options || this.options;\n        if (options.clear) {\n            this.reset();\n        }\n    }\n\n    onFail(error: XMLHttpRequest, options: ?Options) {\n        options = options || this.options;\n        if (!options.quiet) {\n            let errors = options.formatErrorResponse(error);\n            this.errors.record(errors, options.timeout);\n            if (this.errors.hasElements()) {\n                this.errors.scrollToFirst();\n            }\n        }\n    }\n\n    buildBaseUrl(options: ?Options) {\n        options = options || this.options;\n        if (options.url.includes('://')) {\n            return options.url;\n        }\n        let baseUrl = options.baseUrl;\n        let relativeUrl = options.url;\n\n        baseUrl = baseUrl.replace(/\\/+$/g, '');\n        relativeUrl = relativeUrl.replace(/^\\/+/g, '');\n\n        return `${baseUrl}/${relativeUrl}`;\n    }\n\n    makeUrl(options: ?Options): string {\n        let url = this.buildBaseUrl(options);\n        let queryStart = url.includes('?') ? '&' : '?';\n        let fullUrl = url + queryStart;\n        let properties = [];\n        let data = this.getData();\n\n        let params = flattenToQueryParams(data);\n\n        Object.keys(params).forEach(key => {\n            let item = params[key];\n\n            if (isFile(item)) {\n                throw new Error('Cannot convert file to a string');\n            }\n\n            properties.push(key + (isNil(item) ? '' : `=${item}`));\n        });\n        return fullUrl + properties.join('&');\n    }\n\n    addElement(key: string, el: HTMLElement) {\n        this.errors.addElement(key, el);\n    }\n}\n\n\nexport default Form;\n","// @flow\nimport type { Method } from './flow';\nimport type { Data } from \"./Form\";\n\ntype Options = {\n    method: Method,\n    url: string,\n}\n\nexport default function http(method: Method, url: string, data: FormData | Data) {\n    let xhr = new XMLHttpRequest();\n\n    let response = new Promise<XMLHttpRequest>((resolve, reject) => {\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                resolve(xhr);\n            } else {\n                reject(xhr);\n            }\n        };\n        xhr.onerror = () => reject(xhr);\n    });\n\n    xhr.open(method, url);\n    if (data instanceof FormData) {\n        xhr.setRequestHeader('Content-Type', 'multipart/form-data');\n        xhr.send(data);\n    } else {\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.send(JSON.stringify(data));\n    }\n\n    return response;\n}"],"sourceRoot":""}